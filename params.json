{"name":"C0","tagline":"一些关于ｃ的陷阱（Some of the pitfalls）","body":"`c陷阱(不要只看静态的代码，执行过后你会崩溃的)`  \r\n\r\n　　这篇文章是与c相关的第一篇文章，之所以要放在第一篇－－或许你看看标题应该明白了我的意思了，在我们以后写c的过程中\r\n不要让子在奔溃，起码在这一点上，好了，下面就转正文吧：  \r\n　　来看看下面几行简单的c代码：   \r\n　　\r\n　##　test1.c:     \r\n```c\r\n　　\r\n  1 #include <stdio.h>\r\n  2 \r\n  3 int main()\r\n  4 {\r\n  5     const int a = 10;\r\n  6     //int g[a];\r\n  7     int *p = (int*) &a;\r\n  8     *p = 100;\r\n  9     int b = a;\r\n 10 \r\n 11     printf(\"%d\\t%d\\t%d\\n\",　a,　*p,　b);\r\n 12 \r\n 13     return 0;\r\n 14 \r\n 15 }\r\n ```\r\n\r\n想想输出结果是什么？    \r\n看到这估计你应该有自己的结果了．   \r\n我使用的gcc版本是：   \r\ngcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04)    \r\n当我执行:    \r\ngcc test1.c 时生成a.out　执行./a.out   \r\n结果是：   \r\n100   100   100   \r\n\r\n当我执行:   \r\ngcc -O2 test1.c 时生成a.out　执行./a.out   \r\n结果是：   \r\n100   100   10    \r\n\r\n这个时候肯定有人要问这是怎么回事恩？　为何输出的b是10而不是100？   \r\n\r\n\r\n搞清楚这个问题首先我们看点其他的知识点：    \r\n\r\n一．编译优化，由于默认状态下gcc　使用的优化级别是O1，其中优化级别排序是：    \r\nO0 -->> O1 -->> O2 -->> O3   \r\n-O0表示没有优化,-O1为缺省值，-O3优化级别最高   \r\n\r\n二．计算机寻址的方式   \r\n \r\n * 立即数寻址  \r\n \r\n* 寄存器寻址  \r\n\r\n* 存储器寻址   \r\n\r\n\r\n然后再来看看这几个问题：    \r\n刚才默认状态下输出都是100，当提高了优化级别的时候最后b是10.其实当提高了编译优化参数的时候\r\n此时编译器对其＂const int a = 10;＂做了优化，由于是const修饰了变量a，所以最终寻址a的时候\r\n就是用立即数寻址方式．此时语句＂*p = 100;＂虽然把变量a中的内存修改了但是下面语句＂int b = a;\r\n被编译器优化了，此时使用的立即数的方式，不会再从内存中读取变量ａ．   \r\n\r\n注意：    \r\n当我们在使用＂volatile＂关键字的时候，此时结果又会不一样的．volatile告诉编译器每次访问的时候必须\r\n去从内存中去读取．   \r\n\r\n下面再看看二者在汇编上的差异：   \r\n\r\n优化前：   \r\n```c\r\n 10         .cfi_startproc\r\n 11         pushq   %rbp\r\n 12         .cfi_def_cfa_offset 16\r\n 13         .cfi_offset 6, -16\r\n 14         movq    %rsp, %rbp\r\n 15         .cfi_def_cfa_register 6\r\n 16         subq    $16, %rsp\r\n 17         movl    $10, -16(%rbp)\r\n 18         leaq    -16(%rbp), %rax\r\n 19         movq    %rax, -8(%rbp)\r\n 20         movq    -8(%rbp), %rax\r\n 21         movl    $100, (%rax)\r\n 22         movl    -16(%rbp), %eax\r\n 23         movl    %eax, -12(%rbp)\r\n 24         movq    -8(%rbp), %rax\r\n 25         movl    (%rax), %edx\r\n 26         movl    -16(%rbp), %eax\r\n 27         movl    -12(%rbp), %ecx\r\n 28         movl    %eax, %esi\r\n 29         movl    $.LC0, %edi\r\n 30         movl    $0, %eax\r\n 31         call    printf\r\n 32         movl    $0, %eax\r\n 33         leave\r\n 34         .cfi_def_cfa 7, 8\r\n 35         ret\r\n 36         .cfi_endproc\r\n```\r\n\r\n\r\n优化后：   \r\n\r\n```c\r\n 11         .cfi_startproc\r\n 12         subq    $8, %rsp\r\n 13         .cfi_def_cfa_offset 16\r\n 14         movl    $10, %r8d\r\n 15         movl    $100, %ecx\r\n 16         movl    $100, %edx\r\n 17         movl    $.LC0, %esi\r\n 18         movl    $1, %edi\r\n 19         xorl    %eax, %eax\r\n 20         call    __printf_chk\r\n 21         xorl    %eax, %eax\r\n 22         addq    $8, %rsp\r\n 23         .cfi_def_cfa_offset 8\r\n 24         ret\r\n 25         .cfi_endproc\r\n```\r\n\r\n所以在写代码地的时候一定要想清楚了在写．   \r\n\r\n\r\n下面在看一个列子：   \r\ntest2.c   \r\n```c\r\n  1 \r\n  2 #include<stdio.h>\r\n  3 \r\n  4 \r\n  5 int  main()\r\n  6 {\r\n  7     int a=12;\r\n  8     float b = 12.99;\r\n  9     float c = 12.25;\r\n 10 \r\n 11 \r\n 12     printf(\"%d\\t%d\\t%f\\n\",a, b, c);\r\n 13 \r\n 14     return 0;\r\n 15 }\r\n```\r\n\r\n看清楚printf函数中给的格式符号：有人可能会说b是12 c是12.25.   \r\n其实并不是这样的．   \r\n\r\n所以最基础printf函数的实现原理你知道嘛？  \r\n在这个过程中其实是这样的参数cba从右边依次压栈，然后看到\"%d\"格式符则取出四字节，   \r\n看大%f按照８字节来做解析(在printf函数中float型都会转化为double来处理所以８bit).    \r\n\r\n\r\ntest3.c    \r\n\r\ni++ 与　++i的区别：   \r\n最基本的都知道．但是真正的区别又是什么恩？   \r\ni++ = 3;//编译不通过   \r\n++i = 4;　  \r\n\r\n第一种为啥编译不通过恩，其实i++底层是这样做的，i++会生成中间一个临时常量  \r\n此行相当于向常量赋值．   \r\n\r\n\r\n基于此类别其实还有很多，其实有时候很简单的一句代码，但是底层却有很多好玩的．    \r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"一些关于ｃ的陷阱（Some of the pitfalls）","note":"Don't delete this file! It's used internally to help with page regeneration."}